################################################################################
#                                 TESTS                                        
################################################################################

test_path = meson.source_root()+'/test/'
expressions_path = test_path+'expressions/'
programs_path = test_path+'lisp_programs/'
bad_expressions_path = expressions_path+'badexpressions/'

# Parser test for accepted sexpressions
parser_accepted_strings_test = executable(
    'parser_accepted_strings_test', 'parser_accepted_strings_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for parser for accepted sexpressions
test('[PAR] Void file test', parser_accepted_strings_test, args : [expressions_path+'void.lisp'])
test('[PAR] Atoms test', parser_accepted_strings_test, args : [expressions_path+'atoms.lisp'])
test('[PAR] Single atom test', parser_accepted_strings_test, args : [expressions_path+'atom.lisp'])
test('[PAR] Dot sexpressions test', parser_accepted_strings_test, args : [expressions_path+'dotexpressions.lisp'])
test('[PAR] List notation accepted strings 1', parser_accepted_strings_test, args : [expressions_path+'listnotation1.lisp'])
test('[PAR] List notation accepted strings 2', parser_accepted_strings_test, args : [expressions_path+'listnotation2.lisp'])

# Parser test for rejected sexpressions
parser_rejected_strings_test = executable(
    'parser_rejected_strings_test', 'parser_rejected_strings_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for parser for rejected sexpressions
test('[REJ] Bad sexpression with closed par test', parser_rejected_strings_test, args : [bad_expressions_path+'closedpar.lisp'])
test('[REJ] Incomplte sexpression test', parser_rejected_strings_test, args : [bad_expressions_path+'unfinished.lisp'])
test('[REJ] Complicate bad sexpression test', parser_rejected_strings_test, args : [bad_expressions_path+'complicate.lisp'])

# Sexpression print tester for self-referencing structures
recursive_structure_print_test = executable(
    'recursive_structure_print_test', 'recursive_structure_print_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for parser for rejected sexpressions
test('[PRINT] Print self-referencing structures test', recursive_structure_print_test)

# Print test for accepted sexpressions
print_test = executable(
    'print_test', 'print_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for print sexpressions
test('[PRINT] Void file print test', print_test, args : [expressions_path+'void.lisp'])
test('[PRINT] Atoms print test', print_test, args : [expressions_path+'atoms.lisp'])
test('[PRINT] Single atom print test', print_test, args : [expressions_path+'atom.lisp'])
test('[PRINT] Dot sexpressions print test', print_test, args : [expressions_path+'dotexpressions.lisp'])
test('[PRINT] Print list notation accepted strings 1', print_test, args : [expressions_path+'listnotation1.lisp'])
test('[PRINT] Print list notation accepted strings 2', print_test, args : [expressions_path+'listnotation2.lisp'])

# Print test for tokens
print_lexer_test = executable(
    'print_lexer_test', 'print_lexer_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for print tokens
test('[PRINT] Tokens print test', print_lexer_test, args : [expressions_path+'tokens.lisp'])

# Bad prints test
bad_prints_test = executable(
    'bad_prints_test', 'bad_prints_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for bad prints
test('[PRINT] Recognize bad prints test', bad_prints_test, args : [expressions_path+'tokens.lisp'])

# Sexpr copy test
sexpr_copy_test = executable(
    'sexpr_copy_test', 'sexpr_copy_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases for bad prints
test('[COPY] Sexpression copy test', sexpr_copy_test, args : [])

# Lisp program test
lisp_program_test = executable(
    'lisp_program_test', 'lisp_program_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases lisp programs prints
test('[LISP] +', lisp_program_test, args : [
    '(+ 1 1 1)',
    '3 ',
    'L+'
])
test('[LISP] -', lisp_program_test, args : [
    '(- 1 1)',
    '0 ',
    'L-'
])
test('[LISP] *', lisp_program_test, args : [
    '(* -1 -1)',
    '1 ',
    'L*'
])
test('[LISP] /', lisp_program_test, args : [
    '(/ 8 2 (+ 1 1))',
    '2 ' ,
    'LFR'
])
test('[LISP] or 1', lisp_program_test, args : [
    '(set \'n 1)(or n "ciao" n NIL)',
    '1 ',
    'LOR1'
])
test('[LISP] or 2', lisp_program_test, args : [
    '(or NIL NIL NIL NIL NIL)',
    'NIL',
    'LOR2'
])
test('[LISP] and 1', lisp_program_test, args : [
    '(and 1 NIL)',
    'NIL ' ,
    'LAND1'
])
test('[LISP] and 2', lisp_program_test, args : [
    '(or "hey" 7 "hey")',
    '"hey"',
    'LAND2'
])
test('[LISP] not 1', lisp_program_test, args : [
    '(not T)',
    'NIL',
    'LNOT1'
])
test('[LISP] not 2', lisp_program_test, args : [
    '(not NIL)',
    'T ',
    'LNOT2'
])
test('[LISP] car 1', lisp_program_test, args : [
    '(car \'(a b))',
    'A ',
    'LCAR1'
])
test('[LISP] car 2', lisp_program_test, args : [
    '(car \'((a a) b))',
    '(A A) ',
    'LCAR2'
])
test('[LISP] >', lisp_program_test, args : [
    '(set \'n 1)(> n (- 0 100))',
    'T ',
    'L>'
])
test('[LISP] >=', lisp_program_test, args : [
    '(set \'n 1)(>= n n)',
    'T ',
    'L>='
])
test('[LISP] <', lisp_program_test, args : [
    '(set \'n 1)(< (* 100 100) n)',
    'NIL ',
    'L<'
])
test('[LISP] <=', lisp_program_test, args : [
    '(set \'n 1)(<= n n)',
    'T ',
    'L<='
])
test('[LISP] lambda: id', lisp_program_test, args : [
    '(set \'str "hi")(set \'id (lambda (x) x)) (id str)',
    '"hi" ',
    'LLID'
])
test('[LISP] lambda: ff', lisp_program_test, args : [
    '(set \'ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) (set \'str "hi") (ff \'(((((str)7)8))))',
    'str ',
    'LLFF'
])
test('[LISP] nth 1', lisp_program_test, args : [
    '(nth 1 \'(a b c) )',
    'B ',
    'LNTH1'
])
test('[LISP] nth 2', lisp_program_test, args : [
    '(nth 100 \'(a (1 2) c) )',
    'NIL ',
    'LNTH2'
])
test('[LISP] member 1', lisp_program_test, args : [
    '(set \'n 1)(member n \'(4 1 2 3) )',
    '(1 2 3) ',
    'LMEM1'
])
test('[LISP] member 2', lisp_program_test, args : [
    '(set \'n 1)(member n \'(n n2 NIL) )',
    'NIL',
    'LMEM2'
])
test('[LISP] list', lisp_program_test, args : [
    '(set \'n 1)(list n 1 1)',
    '(1 1 1)',
    'LLIST'
])
test('[LISP] length 1', lisp_program_test, args : [
    '(length \'(NIL NIL NIL) )',
    '3',
    'LLEN1'
])
test('[LISP] length 2', lisp_program_test, args : [
    '(length NIL )',
    '0',
    'LLEN2'
])
test('[LISP] load test', lisp_program_test, args : [
    '(load "'+programs_path+'loadtest.lisp")(+ n 1)',
    '2' ,
    'LLOAD'
])
test('[LISP] env printing test', lisp_program_test, args : [
    '(env)',
    'T',
    'LENV'
])

test('[LISP] set-sum test', lisp_program_test, args : [
    '(+ 1 2) (+ 1 2) (+ 1 2) (set \'n 3) n (+ 1 n)',
    '4',
    'LSUMSET'
])

test('[LISP] set-lambda test 1', lisp_program_test, args : [
    '(set \'id (lambda (x) x)) (set \'n 1) (id 1)',
    '1',
    'LLSET'
])

test('[LISP] set test', lisp_program_test, args : [
    '(set \'n1 1) (set \'n2 2) (set \'ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) (ff \'(((n1 . n2))))',
    'n1',
    'LSET'
])

test('[LISP] dotimes test', lisp_program_test, args : [
    '(set \'n1 1) (set \'n2 2) (set \'ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) (dotimes (n 100) (ff \'(n1 n2)))',
    'NIL',
    'LDOTIMES'
])

test('[LISP] to zero dotimes test', lisp_program_test, args : [
    '(set \'toz (lambda (x) ( cond ( (eq x 0) 0 ) ( T (toz (- x 1)))))) (time (dotimes (n 10) (toz n)))',
    'NIL',
    '30'
])

test('[LISP] cond test', lisp_program_test, args : [
    '(cond (nil nil) ((not nil) 1 ) (t 2) (t 1))',
    '1',
    'LCOND'
])

test('[LISP] stress test 1', lisp_program_test, args : [
    '(set \'toz (lambda (x) ( cond ( (eq x 0) 0 ) ( T (toz (- x 1)))))) (set \'ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) (set \'iso (lambda (x) (cond ((eq x 1) 1 ) ((eq x 2) 2) (t 666)))) (set \'plo (lambda (n) (+ 1 n))) (dotimes (n 5) (toz 5)) (ff \'(a)) (ff \'((((a) b ) c ) d)) (ff \'((a) b )) ((lambda (x) (cond ((eq x 1) 1 ) ((eq x 2) 2) (t 666))) \'(1)) ((lambda (x) x) \'(1)) ((lambda (x) (lambda (y) y)) 1 ) (((lambda (x) (lambda (y) 2))  ) ) (((lambda (x) (lambda (y) y)) 1 ) 2) (((lambda (x) (lambda (y) y)) 1 2 ) 3) ((((lambda (x) (lambda (y) (lambda (z) z))) 1 ) 2) 3) ( (lambda (x) (+ 1 x ) ) 1 ) (set \'ivar (lambda (x) (set \'var x))) (set \'l \'(nil (1 2) ((1)(2)) nil "ciao")) (or nil nil nil \'(1 2 3) 4) (set \'toz (lambda (x) ( cond ( (eq x 0) 0 ) ( T (toz (- x 1)))))) (dotimes (n 1) (toz n)) (dotimes (n 2) (toz n)) (dotimes (n 3) (toz n)) (dotimes (n 3) (+ 1 n)) (dotimes (n 1) 666) (dotimes (n 2) 666) (dotimes (n 3) 666) NIL',
    'NIL',
    'LSTRESS'
])

test('[LISP] label test', lisp_program_test, args : [
    '((label ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) \'((a)))',
    'A',
    'LLABEL'
])

test('[LISP] builtin setq test', lisp_program_test, args : [
    '(setq fun (lambda (x) x)) fun',
    '(lambda (x) x)',
    'LBSETQ'
])

test('[LISP] builtin defun test', lisp_program_test, args : [
    '(defun ff (x) (cond ((atom x) x ) (t (ff (car x)))) ) (ff \'(((a. c) .b)))',
    'a',
    'LBDEFUN'
])

test('[LISP] write function test', lisp_program_test, args : [
    '(setq num 1) (write (+ 1 num))',
    '2',
    'LWRITE'
])

test('[LISP] bye test', lisp_program_test, args : [
    '(BYE)',
    'BYE',
    'LBYE'
])

test('[LISP] map test 1', lisp_program_test, args : [
    '(map 1+ \'(99 100 101))',
    '(100 101 102)',
    'LMAP1'
])

test('[LISP] map test 2', lisp_program_test, args : [
    '(map 1+ NIL)',
    'NIL',
    'LMAP2'
])

test('[LISP] map test 3', lisp_program_test, args : [
    '(map not \'(1 2 NIL NIL "hi"))',
    '(NIL NIL T T NIL)',
    'LMAP3'
])

test('[LISP] subseq test 1', lisp_program_test, args : [
    '(subseq "ciao" 1 2)',
    '"i"',
    'LSUBSEQ1'
])

test('[LISP] subseq test 2', lisp_program_test, args : [
    '(subseq "stringa composta" 0 8)',
    '"stringa "',
    'LSUBSEQ2'
])

test('[LISP] reverse test 1', lisp_program_test, args : [
    '(not (reverse NIL))',
    'T',
    'LREVERSE1'
])

test('[LISP] reverse test 2', lisp_program_test, args : [
    '(setq l \'(1 2 3 (4 5))) (reverse l)',
    '((4 5) 3 2 1)',
    'LREVERSE2'
])

test('[MACRO] simple macro test', lisp_program_test, args : [
    '((macro (name val) (set name val)) hi 1) hi',
    '1',
    'MMACRO'
])

test('[MACRO] mysetq test', lisp_program_test, args : [
    '(set \'mysetq (macro (name val) (set name val))) (mysetq ciao 1) ciao',
    '1',
    'MMYSETQ'
])

test('[MACRO] mydefun test 1', lisp_program_test, args : [
    '(set \'mydefun (macro (name param body) (list \'set (list \'quote name) (list \'lambda param body)))) (mydefun id (x) x) (id "hi")',
    '"hi"',
    'MMYDEFUN1'
])

test('[MACRO] mydefun test 2', lisp_program_test, args : [
    '(set \'mydefun (macro (name param body) (list \'set (list \'quote name) (list \'lambda param body)))) (mydefun toz (n) (cond ((eq n 0) 0) (t (toz (- n 1)))) ) (toz 100)',
    '0',
    'MMYDEFUN2'
])

test('[MACRO] mydefun test 3', lisp_program_test, args : [
    '(set \'mydefun (macro (name param body) (list \'set (list \'quote name) (list \'lambda param body)))) (mydefun ff (x) (cond ((atom x) x ) (t (ff (car x)))) ) (ff \'((((a)))))',
    'a',
    'MMYDEFUN3'
])

test('[MACRO] mydefun test 4', lisp_program_test, args : [
    '(set \'mydefun (macro (name param body) (list \'set (list \'quote name) (list \'lambda param body)))) (mydefun triple (x) (* x 3) ) (triple 333)',
    '999',
    'MMYDEFUN4'
])

# (set 'toz (lambda (x) ( cond ( (eq x 0) 0 ) ( t (toz (- x 1))))))
# ((label ff (lambda (x) (cond ((atom x) x ) (t (ff (car x)))))) '((a))

# Lisp program loaded from file test
lisp_program_load_test = executable(
    'lisp_program_load_test', 'lisp_program_load_test.c',
    include_directories : inc,
    link_with : pilisplib
)
# Cases lisp programs prints
test('[LOAD] first load test', lisp_program_load_test, args : [
    programs_path+'loadtest.lisp',
    '1',
    '1',
    'LOAD'
])

test('[LOAD] set-style maze test', lisp_program_load_test, args : [
    programs_path+'maze_old.lisp',
    '(solveMaze maze1)',
    '(2 3 1 0)',
    'SETMAZE'
])

test('[LOAD] builtin defun and setq maze test', lisp_program_load_test, args : [
    programs_path+'maze.lisp',
    '(solveMaze maze1)',
    '(2 3 1 0)',
    'MAZEBUILTIN'
])

test('[LOAD] diff calculator: d(33x)', lisp_program_load_test, args : [
    programs_path+'diff.lisp',
    '(d \'(* x 33))',
    '(+ (* 1 33) (* X 0))',
    'DIFF1'
])

test('[LOAD] diff calculator: d(x^2)', lisp_program_load_test, args : [
    programs_path+'diff.lisp',
    '(d \'(expt x 2))',
    '(* (EXPT X . 1) 2)',
    'DIFF2'
])

test('[LOAD] diff calculator: d((x^2+1)/cos(x))', lisp_program_load_test, args : [
    programs_path+'diff.lisp',
    '(d \'(/ (+ (expt x 2) 1) (cos x)))',
    '(/ (- (* (+ (* (EXPT X . 1) 2) 0) (COS X)) (* (+ (EXPT X 2) 1) (* (* (SIN X) -1) 1))) (EXPT (COS X) 2))',
    'DIFF3'
])

test('[LOAD] max in list', lisp_program_load_test, args : [
    programs_path+'max.lisp',
    '(list_max (list 1 2 3 4 5 6 7 8 9 1024))',
    '1024',
    'MAX'
])

test('[LOAD] factorial 10', lisp_program_load_test, args : [
    programs_path+'factorial.lisp',
    '(factorial 10)',
    '3628800',
    'FACT1'
])

test('[LOAD] factorial -1: NIL', lisp_program_load_test, args : [
    programs_path+'factorial.lisp',
    '(not (factorial -1))',
    't',
    'FACT2'
])

test('[LOAD] let maze', lisp_program_load_test, args :  [
    programs_path+'maze_let.lisp',
    # why this not? beacuse we can't write in a file # an empty cell: it won't write anything
    '(solveMaze maze1)',
    '(2 3 1 0)',
    'LETMAZE'
])

test('[LOAD] string include 1', lisp_program_load_test, args :  [
    programs_path+'ibeforee.lisp',
    '(not (string-include "ciao" "a"))',
    'T',
    'STRINGINCLUDE1'
])

test('[LOAD] string include 2', lisp_program_load_test, args :  [
    programs_path+'ibeforee.lisp',
    '(string-include "STRING" "ANOTHER CAPS LOCK STRING")',
    '"STRING"',
    'STRINGINCLUDE2'
])

test('[LOAD] I before E except after C', lisp_program_load_test, args :  [
    programs_path+'ibeforee.lisp',
    # challange took from: https://www.reddit.com/r/dailyprogrammer/comments/8q96da/20180611_challenge_363_easy_i_before_e_except/
    '(map check \'("a" "zombie" "transceiver" "veil" "icier"))',
    '(t t t NIL NIL)',
    'IBEFEEXCC'
])

test('[LOAD] map and maze with list', lisp_program_load_test, args :  [
    programs_path+'maze.lisp',
    '(map solvemaze \'( \'((1) (0 3) (3 -1) (1 2)) \'((3 1) (0 2 4) (1 5) (0 4) (1 3) (2 8) (-1 7) (6 8) (5 7)) ))',
#'(map solvemaze '( ((1) (0 3) (3 -1) (1 2)) ((3 1) (0 2 4) (1 5) (0 4) (1 3) (2 8) (-1 7) (6 8) (5 7)) ))',
#    '(map solvemaze '( ((1) (0 3) (3 -1) (1 2)) )',
    '((2 3 1 0) (6 7 8 5 2 1 4 3 0))',
    'MAPMAZELIST'
])

test('[LOAD] map and maze with variables', lisp_program_load_test, args :  [
    programs_path+'maze.lisp',
    '(map solvemaze \'(maze1 maze2))',
    '((2 3 1 0) (6 7 8 5 2 1 4 3 0))',
    'MAPMAZEVAR'
])